<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Conversion Rate — Mental Math Dashboard</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- DataTables CSS & JS -->
    <link
      rel="stylesheet"
      href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css"
    />
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>

    <style>
      body {
        background: #f3f4f6;
        color: #1f2937;
      }
      /* Clean up Scrollbars for table */
      #rulesTable_wrapper {
        max-height: 600px;
        overflow-y: auto;
      }
      canvas {
        max-height: 250px;
      }
      /* Custom Focus Ring */
      input:focus {
        outline: none;
        border-color: #2563eb;
        border: 2px solid #3b82f6;
      }
      /* Footer */
    .footer {
      border-top: 1px solid black;
      padding: 2rem;
      margin-top: auto;
      text-align: center;
    }

    .footer a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: 500;
    }

    .footer a:hover {
      text-decoration: underline;
    }
    .footer img {
      display: inherit;
    }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <div class="max-w-5xl mx-auto">
      <header class="mb-8 text-center">
        <h1 class="text-4xl font-extrabold text-gray-900 tracking-tight mb-2">
          Mental Math Shortcut Generator
        </h1>
        <p class="text-lg text-gray-600 max-w-2xl mx-auto">
          Convert currency, units, or rates in your head. Enter a rate to find
          simple mental math steps to find the conversion, keeping you within your preferred
          accuracy range.
        </p>
      </header>

      <main class="grid grid-cols-1 lg:grid-cols-12 gap-6">
        <section class="lg:col-span-4 space-y-4">
          <div class="bg-white rounded-xl shadow-md border border-gray-100 p-6">
            <h2
              class="text-sm font-bold uppercase tracking-wider text-blue-600 mb-4"
            >
              Settings
            </h2>

            <div class="space-y-6">
              <div>
                <label
                  for="rateInput"
                  class="block text-sm font-medium text-gray-700 mb-1"
                  >Conversion Rate</label
                >
                <div class="relative">
                  <input
                    id="rateInput"
                    type="text"
                    value="34"
                    step="0.1"
                    class="w-full pl-3 pr-10 py-3 bg-gray-50 border border-gray-300 rounded-lg text-lg font-semibold transition-all"
                    placeholder="e.g. 34.2"
                    onfocus="validateNumericInput(this)"
                    onkeypress="if(event.key==='Enter') runSingle()"
                  />
                  <div
                    class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none text-gray-400 text-xs"
                  >
                    x
                  </div>
                </div>
              </div>

              <div>
                <div class="flex justify-between items-end mb-1">
                  <label class="text-sm font-medium text-gray-700"
                    >Calculation Accuracy</label
                  >
                  <span
                    id="toleranceValue"
                    class="text-xs font-mono font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded"
                    >±10.0%</span
                  >
                </div>
                <input
                  type="range"
                  id="toleranceSlider"
                  min="1"
                  max="20"
                  value="10"
                  step="0.5"
                  oninput="updateTolerance()"
                  class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                />
                <div
                  class="flex justify-between text-[10px] text-gray-400 mt-1 uppercase font-bold"
                >
                  <span>More Precise</span>
                  <span>Easier Math</span>
                </div>
              </div>

              <button
                onclick="runSingle()"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold shadow-lg shadow-blue-200 transition-all active:scale-[0.98]"
              >
                Generate Shortcuts
              </button>
            </div>
          </div>
        </section>

        <section class="lg:col-span-8">
          <div
            id="rulesOutput"
            class="bg-white rounded-xl shadow-md border border-gray-100 p-6 min-h-[350px]"
          >
            <div class="text-center py-12 text-gray-400">
              <p>
                Enter a rate and click calculate to see mental math shortcuts.
              </p>
            </div>
          </div>
        </section>
      </main>

      <div class="mt-12 text-center">
        <button
          id="additional-information-button"
          onclick="const el = document.getElementById('additional-information'); const isHidden = el.style.display === 'none' || el.style.display === ''; el.style.display = isHidden ? 'block' : 'none'; this.textContent = isHidden ? 'Hide Advanced Conversion Reference ↑' : 'Show Advanced Conversion Reference ↓';// Force DataTables to fix the column widths
  if (isHidden && typeof $.fn.dataTable === 'function') {
    $('#rulesTable').DataTable().columns.adjust();
  }"
          class="text-sm font-semibold text-gray-500 hover:text-blue-600 transition-colors"
        >
          Show Advanced Conversion Reference ↓
        </button>
      </div>

      <section
        id="additional-information"
        style="display: none"
        class="mt-8 space-y-6"
      >
        <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
          <h3 class="text-lg font-bold mb-4">Accuracy Benchmark</h3>
          <canvas id="accuracyChart"></canvas>
        </div>

        <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
          <h3 class="text-lg font-bold mb-4">Complete Rate Reference Table</h3>
          <table id="rulesTable" class="display w-full text-sm">
            <thead class="bg-gray-50 text-left">
              <tr>
                <th>Rate</th>
                <th>Rule</th>
                <th>Steps</th>
                <th>Accuracy %</th>
                <th>Approx</th>
                <th>Error %</th>
                <th>First Op</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
    </div>
<!-- Footer -->
  <footer class="footer">
    <p>Made by <a href="https://www.kylescheer.com" target="_blank">Kyle Scheer</a> • 
    <a href="https://github.com/kyletscheer/mentalmath" target="_blank">
      <i class="bi bi-github"></i> View Code
    </a> • <a href='https://ko-fi.com/scheerapps' target='_blank' rel="noopener" title="Support me on Ko-fi">
            <img height='36' style='border:0px;height:36px;'
            src='https://storage.ko-fi.com/cdn/kofi5.png?v=6' border='0'
            alt='Buy Me a Coffee at ko-fi.com' />
        </a></p>
  </footer>
    <script>
      // ==========================
      // Mental Math Engine
      // ==========================
      let errorTolerance = 10;

      function updateTolerance() {
        errorTolerance = parseFloat(
          document.getElementById("toleranceSlider").value
        );
        document.getElementById("toleranceValue").textContent =
          errorTolerance.toFixed(1) + "%";
        runSingle();
      }

      function multiplySteps(n) {
        const steps = {
          1: [],
          2: ["×2"],
          3: ["×3"],
          4: ["×2", "×2"],
          5: ["×10", "/2"], // Changed from complex shortcut
          6: ["×3", "×2"],
          7: ["×10", "/2", "+2x"], // Changed from complex shortcut
          8: ["×2", "×2", "×2"],
          9: ["×10", "-x"],
          10: ["×10"],
          11: ["×10", "+x"],
        }[n] || ["×" + n];

        return steps;
      }

      function divideSteps(d) {
        const steps = {
          1: [],
          2: ["/2"],
          3: ["/3"],
          4: ["/2", "/2"],
          5: ["×2", "/10"],
        }[d] || ["/" + d];

        return steps;
      }

      function powerSteps(e) {
        if (e > 0) return Array(e).fill("×10");
        if (e < 0) return Array(-e).fill("/10");
        return [];
      }

      function simplifySteps(steps) {
        let out = [];
        for (let i = 0; i < steps.length; i++) {
          let a = steps[i],
            b = steps[i + 1];
          if (
            (a === "×2" && b === "/2") ||
            (a === "/2" && b === "×2") ||
            (a === "×10" && b === "/10") ||
            (a === "/10" && b === "×10")
          ) {
            i++;
          } else {
            out.push(a);
          }
        }
        return out;
      }

      function formatStep(s) {
        return (
          {
            "×2": "Double it",
            "×3": "Triple it",
            "/2": "Divide by 2",
            "/3": "Divide by 3",
            "×10": "Multiply by 10",
            "/10": "Divide by 10",
            "-x": "Subtract the original",
            "+x": "Add the original",
            "+2x": "Add double the original",
          }[s] || s
        );
      }

      function formatReadableSteps(steps) {
        // Find if there are operations that reference the original amount
        let lastOriginalOpIndex = -1;
        for (let i = steps.length - 1; i >= 0; i--) {
          if (steps[i] === "-x" || steps[i] === "+x" || steps[i] === "+2x") {
            lastOriginalOpIndex = i;
            break;
          }
        }

        // If we have operations that reference original, group them with preceding ops
        if (lastOriginalOpIndex !== -1) {
          let grouped = steps.slice(0, lastOriginalOpIndex + 1);
          let after = steps.slice(lastOriginalOpIndex + 1);

          let groupedReadable = grouped.map(formatStep).join(" → ");
          let afterReadable = after.map(formatStep);

          if (after.length > 0) {
            return ["(" + groupedReadable + ")"].concat(afterReadable);
          } else {
            return ["(" + groupedReadable + ")"];
          }
        }

        // No grouping needed
        return steps.map(formatStep);
      }

      function applySteps(amount, steps) {
        let result = amount;
        let original = amount;

        for (let step of steps) {
          if (step === "×2") result *= 2;
          else if (step === "×3") result *= 3;
          else if (step === "/2") result /= 2;
          else if (step === "/3") result /= 3;
          else if (step === "×10") result *= 10;
          else if (step === "/10") result /= 10;
          else if (step === "-x") result -= original;
          else if (step === "+x") result += original;
          else if (step === "+2x") result += 2 * original;
          else if (step.startsWith("×"))
            result *= parseFloat(step.substring(1));
          else if (step.startsWith("/"))
            result /= parseFloat(step.substring(1));
        }

        return result;
      }

      function bestRules(rate) {
        let best = [];
        for (let n = 1; n <= 11; n++) {
          for (let d of [1, 2, 3, 4, 5]) {
            for (let e = -6; e <= 6; e++) {
              let approx = (n / d) * Math.pow(10, e);
              let error = (Math.abs(approx - rate) / rate) * 100;
              if (error > errorTolerance) continue;

              let steps = simplifySteps(
                multiplySteps(n).concat(divideSteps(d)).concat(powerSteps(e))
              );

              // Skip if steps are empty or filtered out
              if (steps.length === 0) continue;

              best.push({
                steps,
                readable: formatReadableSteps(steps),
                approx,
                error,
                score: error * 2 + steps.length * 1.5,
              });
            }
          }
        }

        // Remove duplicates by comparing step sequences
        let unique = [];
        let seenSteps = new Set();

        for (let rule of best) {
          let stepKey = rule.steps.join("|");
          if (!seenSteps.has(stepKey)) {
            seenSteps.add(stepKey);
            unique.push(rule);
          }
        }

        unique.sort(
          (a, b) => a.error - b.error || a.steps.length - b.steps.length
        );
        return unique.slice(0, 3);
      }

      function runSingle() {
        let rate = parseFloat(document.getElementById("rateInput").value);
        let out = document.getElementById("rulesOutput");
        out.innerHTML = "";

        let rules = bestRules(rate);

        if (rules.length === 0) {
          out.innerHTML = `
          <div class="bg-yellow-50 border border-yellow-200 p-3 rounded text-sm text-yellow-800 mt-3">
            <strong>No rules found</strong> within ${errorTolerance}% tolerance. Try increasing the tolerance slider.
          </div>
        `;
          return;
        }

        // Comparison table
        let comparisonHTML = `
        <div class="mt-4 border border-gray-200 rounded">
          <div class="bg-gray-50 px-3 py-2 border-b border-gray-200">
            <h3 class="text-sm font-bold text-gray-900">Comparison</h3>
          </div>
          <table class="w-full text-sm">
            <thead>
              <tr class="border-b border-gray-200 bg-gray-50">
                <th class="text-left py-2 px-3 font-semibold text-gray-700">Rule</th>
                <th class="text-left py-2 px-3 font-semibold text-gray-700">Steps</th>
                <th class="text-left py-2 px-3 font-semibold text-gray-700">Accuracy</th>
                <th class="text-left py-2 px-3 font-semibold text-gray-700">Tradeoff</th>
              </tr>
            </thead>
            <tbody>
      `;

        rules.forEach((r, i) => {
          let tradeoff = "";
          if (i === 0 && rules.length > 1) {
            if (r.steps.length < rules[1].steps.length) {
              tradeoff =
                '<span class="inline-flex px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">Simplest</span>';
            } else if (r.error < rules[1].error) {
              tradeoff =
                '<span class="inline-flex px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">Most accurate</span>';
            } else {
              tradeoff =
                '<span class="inline-flex px-2 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800">Best balance</span>';
            }
          } else if (i === 1 && rules.length > 1) {
            tradeoff = '<span class="text-gray-600 text-xs">Alternative</span>';
          } else if (i === 2) {
            tradeoff = '<span class="text-gray-600 text-xs">Alternative</span>';
          }

          comparisonHTML += `
          <tr class="border-b border-gray-100 hover:bg-gray-50">
            <td class="py-2 px-3"><strong>Rule #${i + 1}</strong></td>
            <td class="py-2 px-3">${r.steps.length}</td>
            <td class="py-2 px-3 font-semibold text-blue-600">${(
              100 - r.error
            ).toFixed(2)}%</td>
            <td class="py-2 px-3">${tradeoff}</td>
          </tr>
        `;
        });

        comparisonHTML += "</tbody></table></div>";

        // Individual rules with examples
        rules.forEach((r, i) => {
          let amountsSet = new Set();
          while (amountsSet.size < 3) {
            amountsSet.add(Math.floor(Math.random() * 100) + 1);
          }
          let example_amounts = [...amountsSet].sort((a, b) => a - b);
          let examples = example_amounts.map((amount) => {
            let result = applySteps(amount, r.steps);
            let actual = amount * rate;
            return {
              amount,
              result: result.toFixed(2),
              actual: actual.toFixed(2),
            };
          });

          let exampleHTML = examples
            .map(
              (ex) =>
                `<span class="inline-block bg-gray-50 px-2 py-1 rounded text-xs">
            ${ex.amount} → <strong>${ex.result}</strong> <span class="text-gray-500">(${ex.actual})</span>
          </span>`
            )
            .join(" ");

          // Build steps HTML with proper formatting for grouped steps
          let stepsHTML = "";
          let stepCounter = 1;

          r.readable.forEach((item) => {
            if (item.startsWith("(")) {
              // This is a grouped step
              let groupedText = item.substring(1, item.length - 1); // Remove parentheses
              stepsHTML += `<div class="flex items-start gap-2 py-1 pl-4 border-l-2 border-blue-300 bg-blue-50 rounded">
              <span class="flex-shrink-0 w-5 h-5 bg-blue-600 text-white rounded-full flex items-center justify-center text-xs font-bold">
                ${stepCounter}
              </span>
              <span class="text-gray-800 text-sm">${groupedText}</span>
            </div>`;
              stepCounter++;
            } else {
              stepsHTML += `<div class="flex items-center gap-2 py-1">
              <span class="flex-shrink-0 w-5 h-5 bg-blue-600 text-white rounded-full flex items-center justify-center text-xs font-bold">
                ${stepCounter}
              </span>
              <span class="text-gray-800 text-sm">${item}</span>
            </div>`;
              stepCounter++;
            }
          });

          let ruleHTML = `
          <div class="border border-gray-200 rounded p-3 mb-3 bg-gray-50">
            <div class="flex items-center justify-between mb-2">
              <h4 class="text-base font-bold text-gray-900">Rule #${i + 1}</h4>
              <div class="flex items-center gap-2">
                <button 
                  onclick="animateSteps(${i}, ${rate})" 
                  class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-xs font-semibold transition-colors">
                  Animate Steps
                </button>
                <div class="text-right">
                  <div class="text-lg font-bold text-blue-600">${(
                    100 - r.error
                  ).toFixed(2)}%</div>
                  <div class="text-xs text-gray-500">≈ ${r.approx.toFixed(
                    4
                  )}</div>
                </div>
              </div>
            </div>
            
            <div class="mb-2">
              ${stepsHTML}
            </div>
            
            <div class="bg-white rounded p-2 border border-gray-200">
              <div class="text-xs font-semibold text-gray-700 mb-1">Examples:</div>
              <div class="flex flex-wrap gap-2">
                ${exampleHTML}
              </div>
            </div>
          </div>
        `;

          out.innerHTML += ruleHTML;
        });

        out.innerHTML += comparisonHTML;

        // Store current rules for animation
        window.currentRules = rules;
        window.currentRate = rate;
      }

      // ==========================
      // Step Animation
      // ==========================
      function animateSteps(ruleIndex, rate) {
        if (!window.currentRules || !window.currentRules[ruleIndex]) return;

        let rule = window.currentRules[ruleIndex];
        let defaultAmount = 50;

        let modal = document.createElement("div");
        modal.className =
          "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";
        modal.innerHTML = `
  <div class="bg-white rounded-xl shadow-xl p-6 max-w-2xl w-full mx-4">
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-xl font-bold text-gray-900">Step-by-Step Animation</h3>
      <button onclick="this.closest('.fixed').remove()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
    </div>
    
    <div class="mb-4 p-4 bg-blue-50 rounded-lg border border-blue-100">
      <label class="block text-xs font-bold text-blue-600 uppercase mb-1">Enter Amount to Convert</label>
      <div class="flex items-center gap-4">
        <input type="text" id="animAmountInput" value="${defaultAmount}" 
          class="text-2xl font-bold text-gray-900 bg-transparent border-b-2 border-blue-300 focus:border-blue-600 outline-none w-32"
          onfocus="validateNumericInput(this)"
          oninput="updateTargetDisplay(${rate})">
        <div class="text-gray-400 text-xl">× ${rate}</div>
      </div>
      <div id="targetDisplay" class="text-sm text-gray-500 mt-2">Target: ${(
        defaultAmount * rate
      ).toFixed(2)}</div>
    </div>
    
    <div id="animationSteps" class="space-y-3 mb-4"></div>
    
    <div id="animationResult" class="hidden p-4 bg-green-50 border border-green-200 rounded-lg mb-4">
      <div class="text-sm text-gray-600 font-medium">Mental Math Result:</div>
      <div class="text-2xl font-bold text-green-700 result-text"></div>
      <div class="text-xs text-green-600 mt-1 compare-text"></div>
    </div>
    
    <div class="flex gap-2">
      <button onclick="startAnimation(${rate}, ${ruleIndex})" 
        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-bold transition-all shadow-lg shadow-blue-100">
        Start Animation
      </button>
    </div>
  </div>`;

        document.body.appendChild(modal);

        // Pre-populate placeholders
        renderStepsPlaceholder(rule.steps);
      }

      // Helper to update the target math as the user types
      function updateTargetDisplay(rate) {
        const val = document.getElementById("animAmountInput").value;
        document.getElementById("targetDisplay").textContent = `Target: ${(
          val * rate
        ).toFixed(2)}`;
      }

      function renderStepsPlaceholder(steps) {
        let stepsContainer = document.getElementById("animationSteps");
        stepsContainer.innerHTML = "";
        steps.forEach((step, i) => {
          let stepDiv = document.createElement("div");
          stepDiv.id = `anim-step-${i}`;
          stepDiv.className =
            "p-3 border border-gray-200 rounded-lg bg-gray-50 opacity-40 transition-all";
          stepDiv.innerHTML = `
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <span class="step-num w-6 h-6 bg-gray-300 text-white rounded-full flex items-center justify-center text-xs font-bold">${
            i + 1
          }</span>
          <span class="text-sm font-semibold text-gray-700">${formatStep(
            step
          )}</span>
        </div>
        <div class="text-right">
          <div id="anim-calc-${i}" class="text-xs text-gray-400 font-mono"></div>
          <div id="anim-result-${i}" class="font-bold text-gray-800"></div>
        </div>
      </div>`;
          stepsContainer.appendChild(stepDiv);
        });
      }

      async function startAnimation(rate, ruleIndex) {
        const amount =
          parseFloat(document.getElementById("animAmountInput").value) || 0;
        const rule = window.currentRules[ruleIndex];
        let currentVal = amount;

        // Reset UI
        document.getElementById("animationResult").classList.add("hidden");
        renderStepsPlaceholder(rule.steps);

        for (let i = 0; i < rule.steps.length; i++) {
          const step = rule.steps[i];
          const stepDiv = document.getElementById(`anim-step-${i}`);
          const calcDiv = document.getElementById(`anim-calc-${i}`);
          const resultDiv = document.getElementById(`anim-result-${i}`);

          stepDiv.classList.replace("opacity-40", "opacity-100");
          stepDiv.className +=
            " border-blue-500 bg-blue-50 ring-2 ring-blue-100";

          let prevVal = currentVal;
          if (step === "×2") currentVal *= 2;
          else if (step === "×3") currentVal *= 3;
          else if (step === "/3") currentVal /= 3;
          else if (step === "/2") currentVal /= 2;
          else if (step === "×10") currentVal *= 10;
          else if (step === "/10") currentVal /= 10;
          else if (step === "-x") currentVal -= amount;
          else if (step === "+x") currentVal += amount;
          else if (step === "+2x") currentVal += 2 * amount;

          calcDiv.textContent = `${prevVal.toFixed(1)} ${step.replace(
            "x",
            amount
          )}`;
          resultDiv.textContent = `= ${currentVal.toFixed(2)}`;

          await new Promise((r) => setTimeout(r, 800));
          stepDiv.className =
            "p-3 border border-green-500 rounded-lg bg-green-50 transition-all";
          stepDiv
            .querySelector(".step-num")
            .classList.replace("bg-gray-300", "bg-green-500");
        }

        const actual = amount * rate;
        const finalResultDiv = document.getElementById("animationResult");
        finalResultDiv.classList.remove("hidden");
        finalResultDiv.querySelector(".result-text").textContent =
          currentVal.toFixed(2);
        finalResultDiv.querySelector(
          ".compare-text"
        ).textContent = `Actual: ${actual.toFixed(2)} | Error: ${Math.abs(
          100-(currentVal/actual * 100)
        ).toFixed(2)}%`;
      }

      // ==========================
      // Table + Chart with Tiered Rates
      // ==========================

      function generateTieredRates() {
        const rates = [];

        const addRange = (start, end, step, precision) => {
          for (
            let i = start;
            i < end;
            i = parseFloat((i + step).toFixed(precision))
          ) {
            rates.push(i);
          }
        };

        addRange(0.001, 0.01, 0.001, 3);
        addRange(0.01, 1, 0.01, 2);
        addRange(1, 10, 0.1, 1);
        addRange(10, 100, 1, 0);
        addRange(100, 1001, 10, 0);

        return rates;
      }

      let rates = generateTieredRates();

      function formatRate(rate) {
        // Remove trailing zeros and unnecessary decimal point
        if (rate >= 1) {
          return rate % 1 === 0
            ? rate.toString()
            : rate.toFixed(1).replace(/\.0$/, "");
        } else if (rate >= 0.01) {
          return rate.toFixed(2).replace(/\.?0+$/, "");
        } else {
          return rate.toFixed(3).replace(/\.?0+$/, "");
        }
      }

      let tableBody = document.querySelector("#rulesTable tbody");
      let accuracyData = [],
        labels = [];

      rates.forEach((r) => {
        let bestArr = bestRules(r);
        let best = bestArr[0];

        let dominant = "—";
        let stepsLength = 0;
        let readable = "—";
        let approx = "—";
        let error = "—";
        let accuracy = "—";

        if (best) {
          dominant = best.steps[0] || "—";
          stepsLength = best.steps.length;
          readable = best.readable.join(" → ");
          approx = best.approx.toFixed(6).replace(/\.?0+$/, "");
          error = best.error.toFixed(2);
          accuracy = (100 - best.error).toFixed(2);
        }

        let row = tableBody.insertRow();
        row.innerHTML = `
        <td>${formatRate(r)}</td>
        <td>${readable}</td>
        <td>${stepsLength}</td>
        <td>${accuracy}</td>
        <td>${approx}</td>
        <td>${error}</td>
        <td>${dominant}</td>
      `;

        labels.push(formatRate(r));
        accuracyData.push(best ? 100 - best.error : null);
      });

      $(document).ready(function () {
        $("#rulesTable").DataTable({
          pageLength: 50,
          order: [[0, "asc"]],
          scrollY: "500px",
          scrollCollapse: true,
        });
      });

      new Chart(document.getElementById("accuracyChart"), {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              data: accuracyData,
              label: "Accuracy %",
              borderColor: "#2563eb",
              backgroundColor: "rgba(37, 99, 235, 0.1)",
              fill: true,
              tension: 0.3,
              pointRadius: 1,
              pointHoverRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              labels: {
                font: { size: 12 },
              },
            },
            tooltip: {
              backgroundColor: "rgba(0, 0, 0, 0.8)",
              padding: 8,
              titleFont: { size: 12 },
              bodyFont: { size: 11 },
            },
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Conversion Rate",
                font: { size: 12, weight: "bold" },
              },
              ticks: {
                maxTicksLimit: 30,
                font: { size: 10 },
              },
            },
            y: {
              title: {
                display: true,
                text: "Accuracy %",
                font: { size: 12, weight: "bold" },
              },
              min: 90,
              max: 100,
              ticks: {
                font: { size: 10 },
              },
            },
          },
        },
      });

      runSingle();

      function validateNumericInput(input) {
        // 1. Block invalid characters during typing
        input.addEventListener("keydown", (e) => {
          const invalidChars = ["e", "E", "+", "-"];
          if (invalidChars.includes(e.key)) {
            e.preventDefault();
          }
        });

        // 2. Sanitize input (for pasted content or mobile browsers)
        input.addEventListener("input", () => {
          let val = input.value;
          // Remove anything that isn't a digit or a dot
          val = val.replace(/[^0-9.]/g, "");
          // Ensure only one decimal point exists
          const parts = val.split(".");
          if (parts.length > 2) {
            val = parts[0] + "." + parts.slice(1).join("");
          }
          input.value = val;
        });
      }
    </script>
  </body>
</html>
